> 面试官会问：
1. 请求行是哪三部分组成？   
2. 一共有多少种请求方式
3. get vs post？
4. http协议有几个？ 1.1 和 2.0 有什么区别？还有其他的协议吗？
5. 常见的请求头部有什么？
6. http vs rpc？
7. post为什么是两个数据包？ 
8. http 有什么优缺点（这个问题不好）

**解答**
## 1. 请求行是哪三部分组成？ 
 方法 资源uir http协议及版本

```bash
GET /index.html HTTP/1.1
```

## 2. http请求一共有多少种请求方式？
GET、POST、PUT、DELETE、OPTIONS、PATCH、HEAD、TRACE

如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT.

## 3. get vs post？
1. 参数传递方式
2. 安全性
3. 缓存
4. 幂等性
5. 语义

|GET|POST|
|-|-|
|刷新无害|数据会被重新提交|
|数据长度限制/URL长度2048字符|长度无限制（协议不限制；实际上受nginx和PHP的限制，php还会限制post报文变量的个数）|
|数据可见/安全性差|不可见/更安全|
|可以被缓存|不可以被缓存|
|书签可收藏|书签不可收藏|

### get和post区别总结
get：刷新无害、可收藏、长度有限定、可以被缓存、可见安全性差、发送一个tcp数据包

GET 用于获取信息，是无副作用的，是幂等的，且可缓存
POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存

## 4. http协议有几个？ 1.1 和 2.0 有什么区别？还有其他的协议吗？
http 1.0 1.1 1.2 google的spdy已经融入到了http2.0，Google已经放弃了，quic（也是谷歌的）。

至少说出 1.0、1.1、2.0差别，quic可以了解。
### 缺点：
#### 1.0 缺点
短连接

浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接（TCP连接的新建成本很高，因为需要客户端和服务器三次握手），服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求；

#### 1.1 缺点
- 线程阻塞 --> 队头堵塞

**线程阻塞**

线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制数目的请求会被阻塞。

**队头堵塞** 

虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着。这将导致“队头堵塞”

避免方式：一是减少请求数，二是同时多开持久连接

### 优点
#### 1.1优点
**1.1支持：**
- 长连接
- 缓存增加
- 支持Host
- 错误通知
- 带宽优化

- 新增请求方式
- 管道机制 

管道机制，一个tcp链接，可以发送多个请求。

#### 2.0 优点
1. 二进制格式    而非文本格式；
2. 完全多路复用   ，而非有序并阻塞的、只需一个连接即可实现并行；
3. 报头压缩   ，降低开销
4. 服务器推送   // 用的人太少，已经被废弃了，（chrome已经不支持了）

**2.0特点详解**
1. 二进制协议
   
HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。

二进制协议解析起来更高效、“线上”更紧凑，更重要的是错误更少。

1. 完全多路复用

HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。

3. 报头压缩

HTTP 协议是没有状态，导致每次请求都必须附上所有信息。所以，请求的很多头字段都是重复的，比如Cookie，一样的内容每次请求都必须附带，这会浪费很多带宽，也影响速度。

对于相同的头部，不必再通过请求发送，只需发送一次；

HTTP/2 对这一点做了优化，引入了头信息压缩机制；

一方面，头信息使用gzip或compress压缩后再发送；

另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，产生一个索引号，之后就不发送同样字段了，只需发送索引号。

4. 服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源；

通过推送那些服务器任务客户端将会需要的内容到客户端的缓存中，避免往返的延迟

### quic
如果你的 App，在不需要任何修改的情况下就能提升 15% 以上的访问速度。特别是弱网络的时候能够提升 20% 以上的访问速度。

如果你的 App，在频繁切换 4G 和 WIFI 网络的情况下，不会断线，不需要重连，用户无任何感知。如果你的 App，既需要 TLS 的安全，也想实现 HTTP2 多路复用的强大。

如果你刚刚才听说 HTTP2 是下一代互联网协议，如果你刚刚才关注到 TLS1.3 是一个革命性具有里程碑意义的协议，但是这两个协议却一直在被另一个更新兴的协议所影响和挑战。

如果这个新兴的协议，它的名字就叫做“快”，并且正在标准化为新一代的互联网传输协议。

你愿意花一点点时间了解这个协议吗？你愿意投入精力去研究这个协议吗？你愿意全力推动业务来使用这个协议吗？

Quic 全称 quick udp internet connection ，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。

Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势 ：

1. 减少了 TCP 三次握手及 TLS 握手时间
2. 改进的拥塞控制
3. 避免队头阻塞的多路复用
4. 连接迁移
5. 前向冗余纠错

不是4层的协议，应该说是一个4+5+7层的协议，综合实现了TCP ,TLS, HTTP2的功能。7层协议就是http2。


## 5. 常见的请求头部有什么？
Host、Content-length、Accept、Content-type（application/x-www-form-urlencoded标准表单、multipart/form-data上传文件）、Connection、Referer、Cookie

## 6. http vs rpc？

HTTP 和 RPC 其实是两个维度的东西：

- HTTP 指的是通信协议
- RPC 则是远程调用，其对应的是本地调用

### 那为什么要有 RPC？
可能你常听到什么什么之间是 RPC 调用的，那你有没有想过为什么要 RPC， 我们直接 WebClient HTTP 调用不行么？

微服务，其实 RPC 调用是因为服务的拆分，或者本身公司内部的多个服务之间的通信。

服务的拆分独立部署，那服务间的调用就必然需要网络通信，用 WebClient 调用当然可行，但是比较麻烦。

我们想即使服务被拆分了但是使用起来还是和之前本地调用一样方便。

所以就出现了 RPC 框架，来屏蔽这些底层调用细节，使得我们编码上还是和之前本地调用相差不多。

并且 HTTP 协议比较的冗余，RPC 都是内部调用所以不需要太考虑通用性，只要公司内部保持格式统一即可。

所以可以做各种定制化的协议来使得通信更高效。

所以公司内部服务的调用一般都用 RPC，而 HTTP 的优势在于通用，大家都认可这个协议。

所以三方平台提供的接口都是通过 HTTP 协议调用的。

所以现在知道为什么我们调用第三方都是 HTTP ，公司内部用 RPC 了吧？

### rpc
RPC主要用于公司内部服务调用，传输效率高（TCP，报文小），性能消耗低（高效的二进制传输、字节小、序列化耗时少），服务治理方便。

RPC：可以基于HTTP协议，也可以基于TCP协议

HTTP：基于HTTP协议

rpc是远端过程调用，其调用协议通常包含传输协议和序列化协议。
所以为什么要用rpc调用？

因为良好的rpc调用是面向服务的封装，针对服务的可用性和效率等都做了优化。单纯使用http调用则缺少了这些特性。

~~## 7. post为什么是两个数据包？~~ 
~~这个其实是有争议的~~

## 8. http 有什么优缺点？
基于应用级的接口，http的灵活性高、可靠传输
明文传输不安全


## 9.rpc
1. gRPC：gRPC是Google公布的开源项目，基于HTTP2.0协议，并支持常见的众多编程语言。HTTP 2.0协议是基于二进制的HTTP协议的升级版本，gRPC底层使用了Netty框架。
2. Thrift：Thrift是Facebook的一个开源项目，主要是一个跨语言的服务开发框架。它有一个代码生成器来对它所定义的IDL文件自动生成服务代码框架。Thrift对于底层的RPC通讯都是透明的，用户只需要对其进行二次开发即可，省去了一系列重复的前置基础开发工作。
3. Dubbo：Dubbo是阿里集团开源的一个极为出名的RPC框架，在很多互联网公司和企业应用中广泛使用。协议和序列化框架都可以插拔是及其鲜明的特色。

其实传输协议、传输效率、性能通过使用http2.0没有什么太大的区别。

### 主要区别是

1. 服务治理
2. 负载均衡
3. 传输效率
4. 性能消耗

#### 服务治理（下游服务新增，重启，下线时如何不影响上游调用者）

RPC：能做到自动通知，不影响上游

HTTP：需要事先通知，修改Nginx/HAProxy配置

RPC主要用于公司内部服务调用，性能消耗低，传输效率高，服务治理方便。HTTP主要用于对外的异构环境，浏览器调用，APP接口调用，第三方接口调用等等。

#### 负载均衡

RPC：基本都自带了负载均衡策略

HTTP：需要配置Nginx，HAProxy实现


#### 传输协议

RPC：可以基于TCP协议，也可以基于HTTP协议。

HTTP：基于HTTP协议。

#### 传输效率

RPC：使用自定义的TCP协议，可以让请求报文体积更小，或者使用HTTP2.0协议，也可以很好地减少报文体积，提高传输效率。

HTTP：如果时基于HTTP1.1的协议，请求中会包含很多无用的内容；如果是基于HTTP2.0，那么简单地封装一下还是可以作为一个RPC使用的，这时标准RPC框架更多是服务治理。

#### 性能消耗

RPC：可以基于thrift实现高效的二进制传输

HTTP：大部分是通过json实现的，字节大小和序列化耗时都比thrift要更消耗性能


RPC和HTTP都可以用于实现远程过程调用，如何选择

从速度上看，RPC比HTTP更快，虽然底层都是TCP，但是http协议的信息往往比较臃肿，不过可以采用gzip压缩

从难度上看，RPC实现较为复杂，http相对简单

从灵活性上看，HTTP更胜一筹，因为它不关心实现细节，跨平台，跨语言

两者有不同的使用场景：

如果对效率要求更高，并且开发过程使用统一的技术栈，那么RPC还是不错的

如果需要更加灵活，跨语言、跨平台，显然HTTP更合适

再插一句，最近新兴的微服务概念更加强调独立、自治、灵活，而RPC限制较多。因此微服务框架中，一般都会采用HTTP的Restful服务，像在公司内部使用hsf协议，对接外部系统使用微服务。




